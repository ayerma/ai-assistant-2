name: Jira -> Tech Assistant

on:
  workflow_dispatch:
    inputs:
      ticket_id:
        description: "Jira issue key (e.g., PROJ-123)"
        required: true
        type: string
      ticket_summary:
        description: "Jira issue summary (optional, will fetch if not provided)"
        required: false
        type: string
      ticket_description:
        description: "Jira issue description (optional, will fetch if not provided)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  run-tech-assistant:
    runs-on: ubuntu-latest
    env:
      TARGET_REPO: ${{ vars.TARGET_REPO }}
      TARGET_REF: ${{ vars.TARGET_REF || 'main' }}
      TARGET_REPO_PATH: ${{ vars.TARGET_REPO_PATH || 'target-repo' }}
      TARGET_REPO_TOKEN: ${{ secrets.TARGET_REPO_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven

      - name: Build
        run: mvn -q -DskipTests package

      - name: Clone target repository
        run: |
          if [ -z "$TARGET_REPO" ]; then
            echo "[ERROR] TARGET_REPO is required (format: owner/repo)"
            exit 1
          fi

          if [ -n "$TARGET_REPO_TOKEN" ]; then
            CLONE_URL="https://x-access-token:${TARGET_REPO_TOKEN}@github.com/${TARGET_REPO}.git"
          else
            CLONE_URL="https://github.com/${TARGET_REPO}.git"
          fi

          echo "[INFO] Cloning $TARGET_REPO@$TARGET_REF into $TARGET_REPO_PATH"
          git clone --depth 1 --branch "$TARGET_REF" "$CLONE_URL" "$TARGET_REPO_PATH"

          # Configure git with token for all operations
          cd "$TARGET_REPO_PATH"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if [ -n "$TARGET_REPO_TOKEN" ]; then
            # Update remote URL to use token for push operations
            git remote set-url origin "https://x-access-token:${TARGET_REPO_TOKEN}@github.com/${TARGET_REPO}.git"
            
            # Configure git to use the token globally for this runner
            git config --global credential.helper store
            echo "https://x-access-token:${TARGET_REPO_TOKEN}@github.com" > ~/.git-credentials
            
            # Also set url insteadOf for https GitHub URLs
            git config --global url."https://x-access-token:${TARGET_REPO_TOKEN}@github.com/".insteadOf "https://github.com/"
          fi

      - name: Install GitHub Copilot CLI
        if: ${{ vars.USE_MODELS_API == 'false' }}
        run: |
          echo "Installing GitHub Copilot CLI..."
          npm install -g @github/copilot

          # Add npm bin to PATH
          NPM_PREFIX=$(npm prefix -g)
          echo "$NPM_PREFIX/bin" >> $GITHUB_PATH

          echo "Copilot CLI installed successfully"

      - name: Generate prompt
        working-directory: ${{ env.TARGET_REPO_PATH }}
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}

          USE_MODELS_API: ${{ vars.USE_MODELS_API || 'true' }}

          # Use absolute paths from ai-assistant-2 repo
          DEV_INSTRUCTIONS_PATH: ${{ github.workspace }}/instructions/platform/roles/dev-role.md
          TECHNICAL_REQUIREMENTS_PATH: ${{ github.workspace }}/instructions/platform/technical/technical-requirements.md

          JIRA_ISSUE_KEY: ${{ inputs.ticket_id }}
          JIRA_ISSUE_SUMMARY: ${{ inputs.ticket_summary }}
          JIRA_ISSUE_DESCRIPTION: ${{ inputs.ticket_description }}

          OUTPUT_PROMPT_ONLY: true
          # Tech assistant prompt output file (optional override)
          TECH_PROMPT_OUTPUT_PATH: tech-prompt.txt
          TARGET_REPO_PATH: ${{ env.TARGET_REPO_PATH }}
        run: |
          echo "Generating Tech assistant prompt..."
          java -cp "$GITHUB_WORKSPACE/target/ai-assistant-2-automation-0.1.0-all.jar" com.ayerma.assistant.TechAssistantRunner

      - name: Call GitHub Models API
        if: ${{ vars.USE_MODELS_API == 'true' || vars.USE_MODELS_API == '' }}
        working-directory: ${{ env.TARGET_REPO_PATH }}
        env:
          MODELS_TOKEN: ${{ secrets.MODELS_TOKEN }}
          MODELS_ENDPOINT: ${{ vars.MODELS_ENDPOINT }}
          MODELS_MODEL: ${{ vars.MODELS_MODEL }}

          USE_MODELS_API: true
          OUTPUT_PROMPT_ONLY: false
          # Tech assistant prompt output file (optional override)
          TECH_PROMPT_OUTPUT_PATH: tech-prompt.txt
          # Tech assistant JSON output file (optional override)
          TECH_OUTPUT_PATH: tech-output.json

          TARGET_REPO_PATH: ${{ env.TARGET_REPO_PATH }}

          # Use absolute paths from ai-assistant-2 repo
          DEV_INSTRUCTIONS_PATH: ${{ github.workspace }}/instructions/platform/roles/dev-role.md
          TECHNICAL_REQUIREMENTS_PATH: ${{ github.workspace }}/instructions/platform/technical/technical-requirements.md

          JIRA_ISSUE_KEY: ${{ inputs.ticket_id }}
          JIRA_ISSUE_SUMMARY: ${{ inputs.ticket_summary }}
          JIRA_ISSUE_DESCRIPTION: ${{ inputs.ticket_description }}
        run: |
          echo "Calling GitHub Models API..."
          java -cp "$GITHUB_WORKSPACE/target/ai-assistant-2-automation-0.1.0-all.jar" com.ayerma.assistant.TechAssistantRunner

      - name: Call Copilot CLI
        if: ${{ vars.USE_MODELS_API == 'false' }}
        working-directory: ${{ env.TARGET_REPO_PATH }}
        env:
          GH_TOKEN: ${{ secrets.TARGET_REPO_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.TARGET_REPO_TOKEN }}
          COPILOT_GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
        run: |
          echo "Calling Copilot CLI..."
          copilot --allow-all-tools -p "$(cat tech-prompt.txt)" > tech-output-raw.txt
          
          echo "Extracting JSON from output..."
          python3 -c "
          import re
          import json
          import sys

          with open('tech-output-raw.txt', 'r') as f:
              content = f.read()

          print('[DEBUG] Raw output length:', len(content))
          print('[DEBUG] Last 1000 chars:', content[-1000:])

          # Try multiple JSON extraction strategies
          json_patterns = [
              # Look for JSON in code blocks
              (r'\`\`\`json\s*(\{[^\`]*\})\s*\`\`\`', 'json code block'),
              (r'\`\`\`\s*(\{[^\`]*\})\s*\`\`\`', 'generic code block'),
              # Look for pull_request_url specifically (our expected format)
              (r'(\{[^}]*\"pull_request_url\"[^}]*\"summary\"[^}]*\})', 'PR URL format'),
              # Look for any JSON object with these fields
              (r'(\{(?:[^{}]|\{[^{}]*\})*\"pull_request_url\"(?:[^{}]|\{[^{}]*\})*\})', 'nested PR format'),
              # Last resort: any valid JSON object at the end
              (r'(\{[^\{]*\})\s*$', 'trailing JSON'),
          ]

          parsed = None
          for pattern, desc in json_patterns:
              matches = re.finditer(pattern, content, re.DOTALL | re.MULTILINE)
              for match in matches:
                  json_str = match.group(1)
                  try:
                      candidate = json.loads(json_str)
                      # Validate it has expected fields
                      if isinstance(candidate, dict) and 'pull_request_url' in candidate:
                          parsed = candidate
                          print(f'[SUCCESS] Extracted JSON using: {desc}')
                          break
                  except json.JSONDecodeError:
                      continue
              if parsed:
                  break

          if parsed:
              with open('tech-output.json', 'w') as out:
                  json.dump(parsed, out, indent=2)
              print('[SUCCESS] Wrote JSON output to tech-output.json')
          else:
              print('[ERROR] No valid JSON with pull_request_url found in copilot output')
              print('[INFO] Creating placeholder output - PR URL may need manual extraction')
              # Create a placeholder that won't break the workflow
              placeholder = {
                  'pull_request_url': 'ERROR: Could not extract PR URL from copilot output',
                  'summary': 'Manual review required - check tech-output-raw.txt'
              }
              with open('tech-output.json', 'w') as out:
                  json.dump(placeholder, out, indent=2)
              print('[WARN] Created placeholder output, workflow will continue')
          "

      - name: Upload result
        uses: actions/upload-artifact@v4
        with:
          name: tech-output
          path: |
            ${{ env.TARGET_REPO_PATH }}/tech-prompt.txt
            ${{ env.TARGET_REPO_PATH }}/tech-output.json
            ${{ env.TARGET_REPO_PATH }}/tech-output-raw.txt

      - name: Check for extraction issues and notify Jira
        if: ${{ vars.USE_MODELS_API == 'false' }}
        working-directory: ${{ env.TARGET_REPO_PATH }}
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_ISSUE_KEY: ${{ inputs.ticket_id }}
        run: |
          echo "Checking if JSON extraction succeeded..."
          if grep -q "ERROR: Could not extract PR URL" tech-output.json; then
            echo "[WARN] JSON extraction failed - posting warning to Jira"
            
            COMMENT="⚠️ **Tech Assistant Warning**\n\nCopilot CLI completed execution but the output format was unexpected.\n\nThe implementation may have been completed, but the Pull Request URL could not be automatically extracted.\n\n**Action Required:**\n1. Check the workflow artifacts for \`tech-output-raw.txt\` to review the full output\n2. Manually locate any created Pull Requests in the repository\n3. If a PR was created, attach it to this ticket\n\n[View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"
            
            # Use curl to post comment to Jira
            curl -X POST \
              -u "$JIRA_EMAIL:$JIRA_API_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"body\": \"$COMMENT\"}" \
              "$JIRA_BASE_URL/rest/api/2/issue/$JIRA_ISSUE_KEY/comment"
            
            echo "[INFO] Warning comment posted to Jira ticket"
          else
            echo "[SUCCESS] JSON extraction succeeded, proceeding normally"
          fi

      - name: Attach PR URL to Jira
        if: ${{ vars.USE_MODELS_API == 'false' }}
        working-directory: ${{ env.TARGET_REPO_PATH }}
        env:
          ATTACH_PR_TO_JIRA: true
          JIRA_ISSUE_KEY: ${{ inputs.ticket_id }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          TECH_OUTPUT_PATH: tech-output.json
        run: |
          # Skip if we have placeholder/error JSON
          if grep -q "ERROR: Could not extract PR URL" tech-output.json; then
            echo "[INFO] Skipping PR attachment due to extraction failure (warning already posted)"
            exit 0
          fi
          
          java -cp "$GITHUB_WORKSPACE/target/ai-assistant-2-automation-0.1.0-all.jar" com.ayerma.assistant.TechAssistantRunner
